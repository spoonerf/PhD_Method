---
title: "Global_Method"
author: "Fiona Spooner"
date: "23 March 2016"
output: html_document
---

Step 1 - Calculating Lambdas for each population
```{r}
library(plyr)
library(taRifx)
library(mgcv)
library(zoo)
```


```{r}

#LPI<-read.csv("LPI_populations_IP_fishedit_20140310_nonconf.csv")
LPI<-read.csv("LPI_pops_20160523_edited.csv")

LPI_pop<-subset(LPI, Specific_location==1 & System !="Marine" & Class != "Actinopterygii"& Class != "Cephalaspidomorphi")

ID<-LPI_pop$ID
#pop_data<- LPI_pop[,c(1,63:125)]
pop_data<- LPI_pop[,c(1,65:130)]

#pop_datab <- (pop_data [,2:64] !="NULL")
pop_datab <- (pop_data [,2:67] !="NULL")
points_per_pop1950_2012 = rowSums(pop_datab)
length_id <- data.frame(ID,points_per_pop1950_2012)

LPI_EU<-merge(length_id, LPI_pop, by = "ID")
LPI_EU<-subset(LPI_EU, points_per_pop1950_2012 >=2)

#LPI_EU2<-LPI_EU[,c(1:3,64:126)]
LPI_EU2<-LPI_EU[,c(1:3,66:131)]
LPI_EU2[LPI_EU2 == 'NULL'] = NA

nrow(LPI_EU2)

```


```{r}
source("gm_mean.R")
library(taRifx)
library(zoo)

doFit = function(sp_name) {
  spid2 = subset(LPI_EU2, ID == sp_name)   #subsetting the population data by each population 
  spid = spid2[,4:69]                     #subsetting only the dates
  colnames(spid)<-1950:2015              #renaming the date column names as R doesn't like numbered column names
  
  name<-spid2$Binomial
  id<-spid2$ID
  points<-spid2$points_per_pop1950_2012
  name_id<-paste(name, id, sep="_") #creating id for naming files of plots
  Date<-as.numeric(colnames(spid))
  spidt<-destring(t(spid))
  time<-length(min(which(!is.na(spidt))):max(which(!is.na(spidt))))
  missing<-time-points
  
  Year<-Date[min(which(!is.na(spidt))):max(which(!is.na(spidt)))]
  Population<-spidt[min(which(!is.na(spidt))):max(which(!is.na(spidt)))]
  Population[Population == 0] <- mean(Population, na.rm=TRUE)*0.01 #if a population is zero one year thhis is replaced with 1% of the average population estimate - because you can log zeros
  
  df<-data.frame(Year,Population)
  
  if (sum(na.omit(df$Population<1))>0) {
    df$Population<-df$Population+1
  } 
    
  
  if (points >=6) {           ###should I be trying GAMs for populations with less than six points and if that doesn't fit then use a linear model - here I am automatically fitting a linear model if there are less than six points
    PopN = log10(df$Population)
    if (length(na.omit(PopN)) >=6) {
      SmoothParm = round(length(na.omit(PopN))/2)    ####added na.omit in as was getting " A term has fewer unique covariate combinations than specified maximum degrees of freedom" error
    } else{
      SmoothParm=3
    }
#     mg1<-mgcv:::gam(Population ~ s(Year))
#     mg2<-mgcv:::gam(PopN ~ s(Year))
    mg2<-mgcv:::gam(PopN ~ s(Year, k=SmoothParm), fx=TRUE)
    pv2 <- predict(mg2,df,type="response",se=TRUE) 
    R_sq2<-summary(mg2)$r.sq
    model<-1
    pv2$fit[pv2$fit <= 0] <- NA
    lambda2<-diff(pv2$fit)
    lambda_sum2<-sum(lambda2, na.rm=TRUE)
    lambda_mean2<-mean(lambda2, na.rm=TRUE)

  } else {
    SmoothParm<-NA
    PopN = log10(df$Population)
    ml2<-lm(PopN~df$Year)
    R_sq2<-summary(ml2)$r.sq
    model<-0
    Pop_interp2<-na.approx(PopN)
    Pop_interp2[Pop_interp2<=0] <- NA
    lambda2<-diff(Pop_interp2)
    lambda_sum2<-sum(lambda2, na.rm=TRUE)
    lambda_mean2<-mean(lambda2, na.rm=TRUE)
 
  }

res_df = data.frame(sp_name=sp_name, points=points, SmoothParm=SmoothParm, r_sq=R_sq2, model=model,lambda_sum=lambda_sum2,lambda_mean=lambda_mean2,time=time, missing=missing)

print(res_df)
return(res_df)
}

all_df_list <- lapply(unique(LPI_EU2$ID), doFit)

```

```{r}
all_matrix <- matrix(unlist(all_df_list, use.names =FALSE), ncol=9, byrow=TRUE)
all_df <- data.frame(all_matrix)
colnames(all_df) <- c("ID", "points","SmoothParm", "r_sq", "model", "lambda_sum","lambda_mean", "length_time", "missing_years")

#write.csv(all_df, "Global_Population_Trends_Rsq_Lambda_16_03_18.csv")
write.csv(all_df, "Global_Population_Trends_Rsq_Lambda_16_08_16.csv") ##updated LPI

```

Step 2 - Extracting the Climate data for each population

```{r}
library(raster)
library(doParallel)
library(beepr)
library(lubridate)
library(reshape2)
library(ncdf4)
```

```{r}
CR30s<-brick("cru_ts3.23.1931.1940.tmp.dat.nc")
CR40s<-brick("cru_ts3.23.1941.1950.tmp.dat.nc")
CR50s<-brick("cru_ts3.23.1951.1960.tmp.dat.nc")
CR60s<-brick("cru_ts3.23.1961.1970.tmp.dat.nc")
CR70s<-brick("cru_ts3.23.1971.1980.tmp.dat.nc")
CR80s<-brick("cru_ts3.23.1981.1990.tmp.dat.nc")
CR90s<-brick("cru_ts3.23.1991.2000.tmp.dat.nc")
CR00s<-brick("cru_ts3.23.2001.2010.tmp.dat.nc")
CR10s<-brick("cru_ts3.23.2011.2014.tmp.dat.nc")

plot(CR40s[[11]])
```


```{r}
#LPI<-read.csv("LPI_populations_IP_fishedit_20140310_nonconf.csv")
LPI<-read.csv("LPI_pops_20160523_edited.csv")

LPIsp<-subset(LPI, Specific_location==1 & System !="Marine" & Class != "Actinopterygii"& Class != "Cephalaspidomorphi" )

CR<-stack(CR30s,CR40s,CR50s,CR60s,CR70s,CR80s,CR90s,CR00s,CR10s)

plot(CR[[1]])
points(LPIsp$Longitude, LPIsp$Latitude)

xy<-data.frame(LPIsp$Longitude, LPIsp$Latitude)

xy<-unique(xy)     #identifying unique locations to extract climate data from 

xy_df<-data.frame(xy)
colnames(xy_df)<-c("lon", "lat")
coordinates(xy_df) <- c("lon", "lat")

length(xy_df)

```

```{r}

n<-6#number of cores to use - not sure how many I can go up to - 6 at UCL
cl<-makeCluster(n)
registerDoParallel(cl)  
getDoParWorkers()

buff<- function (year,b)  {
  
  rasterex<-raster:::extract(CR[[year]], xy_df, buff=b, fun=mean, na.rm=TRUE)
  return(rasterex)
  
}

```

```{r}
diam<-0 #size of buffer to use - in metres
lyr<-1:nlayers(CR)

stime <- system.time({
  sr <- foreach(1, .combine = cbind) %dopar% mapply(buff,lyr,diam)
})
stime
beep(3)

stopCluster(cl)

```

```{r}

dates<-seq(ymd('1931-01-16'),ymd('2014-12-16'), by = 'months')


datesr<-rep(dates, each=length(xy[,1]))   #each number should be number of pops

srm<-melt(sr)

lon<-xy[,1]
lat<-xy[,2]

srm2<-cbind(lon,lat,datesr, srm)

srm3<-srm2[,c(1,2,3,6)]

colnames(srm3)<-c("Longitude", "Latitude", "Date", "Mean_T")

LPI_ID<-LPIsp[,c("ID", "Longitude", "Latitude")]

LPIclim<-merge(srm3, LPI_ID, by=c("Longitude", "Latitude"))

#write.csv(LPIclim, "Global_Mean_Temp_All_LPI_nobuff_1931.csv")
write.csv(LPIclim, "Global_Mean_Temp_All_LPI_nobuff_1931_moreLPI.csv")

```

Step 3 - Calculating mean temp change for each population

```{r}

#LPIclim<-read.csv("Global_Mean_Temp_All_LPI.csv")
#LPIclim<-read.csv("Global_Mean_Temp_All_LPI_nobuff.csv")
#LPIclim<-read.csv("Global_Mean_Temp_All_LPI_nobuff_1931.csv")
LPIclim<-read.csv("Global_Mean_Temp_All_LPI_nobuff_1931_moreLPI.csv")
  
LPIclim$Date<-as.Date(LPIclim$Date, "%Y-%m-%d")
LPIclim$Year<-format(LPIclim$Date, "%Y")

#LPI<-read.csv("LPI_populations_IP_fishedit_20140310_nonconf.csv")
LPI<-read.csv("LPI_pops_20160523_edited.csv")

LPIsp<-subset(LPI, Specific_location==1 & System !="Marine" & Class != "Actinopterygii"& Class != "Cephalaspidomorphi" & ID !=4438)

```

```{r}
library(broom)
library(plyr)
library(taRifx)
```

```{r}
lag<-0 #number of years before start date of pop records which I want climate data from

doMean = function(sp_name) {
  spid2 = subset(LPIsp, ID == sp_name)   #subsetting the population data by each population
  spid = spid2[,65:130]                     #subsetting only the dates
  nid<-matrix(rep (NA, 10), nrow=1)                
  colnames(nid)<-1940:1949
  colnames(spid)<-1950:2015
  spid<-cbind(nid, spid)#renaming the date column names as R doesn't like numbered column names
  climid=subset(LPIclim, ID == sp_name)  #subsetting the climate data by each population
  
  year_temp <- ddply(climid, "Year", summarise,          #calculating the annual mean for max temp, min temp and precipitation
                     mean_mean = mean(na.omit(Mean_T)))
  name<-spid2$Binomial
  id<-spid2$ID
  points<-spid2$points_per_pop1950_2012
  name_id<-paste(name, id, sep="_") #creating id for naming files of plots
  Date<-as.numeric(colnames(spid))
  spidt<-destring(t(spid))

  Year<-Date[(min(which(!is.na(spidt)))-lag):max(which(!is.na(spidt)))]
  Population<-spidt[min(which(!is.na(spidt))):max(which(!is.na(spidt)))]

  Mean<-year_temp$mean_mean[(min(which(!is.na(spidt)))-lag):max(which(!is.na(spidt)))]
  # 
  Mean_mon<-climid[climid$Year %in% Year, ]$Mean_T
  year_temp$Year<-as.numeric(year_temp$Year)
  

  # Mean_mon<-climid[climid$Year %in% Year, ]
  # Mean_mon<-Mean_mon[order(as.Date(Mean_mon$Date, format="%Y/%m/%d")),]
  # plot(Mean_mon$Date, Mean_mon$Mean_T, type="l", xlab="Year", ylab="Degrees Celsius", main="Monthly Mean Temperature")
 # abline(lm(Mean_mon$Mean_T~Mean_mon$Date), col="red")
  
  if (sum(is.nan(Mean))!=length(Mean)){
    
    lm_mean<-lm(Mean~Year)
    #lm_mean<-lm(year_temp$mean_mean~year_temp$Year)
    lm_mean_df<-tidy(lm_mean)[2,]  
    mean_df<-cbind(id,lm_mean_df)
    
  } else{
    
    mean_df<-matrix(c(id,NA,NA,NA,NA,NA), nrow=1, ncol=6)
    colnames(mean_df)<-c("id", "term", "estimate", "std.error", "statistic", "p.value")
    mean_df<-data.frame(mean_df)
  }
  
  print(mean_df)  
  return(mean_df)
}

all_df_list <- lapply(unique(LPIsp$ID), doMean)
```

```{r}
all_matrix <- matrix(unlist(all_df_list), ncol=6, byrow=TRUE)
mean_df <- data.frame(all_matrix)
colnames(mean_df) <- c("ID", "Term","Estimate","SE","Statistic","p.val")

mean_df$Estimate<-as.numeric(as.character(mean_df$Estimate))

#write.csv(mean_df, "All_LPI_Mean_Temp_Slope_nobuff.csv")
#write.csv(mean_df, "All_LPI_All_Years_Nobuff.csv")
#write.csv(mean_df, "All_LPI_All_Years_Nobuff_1931.csv")
write.csv(mean_df, "All_LPI_All_Years_Nobuff_1931_moreLPI.csv")#with new version of LPI
```


Step 4 - Extracting Land Use Change Data for each population

```{r, eval=FALSE}
library(raster)

#land_use_layers = list(primf, primn, secdf, secdn,pastr,range,urban,c3ann,c3per,c4ann,c4per,c3nfx)
land_use_layer_names = c("primf", "primn","secdf", "secdn","pastr","range","urban","c3ann","c3per","c4ann","c4per","c3nfx")

yr<-as.character(850:2015)
date<-as.Date(yr, format="%Y" )

for (i in 1:length(land_use_layer_names)){

layer <-land_use_layer_names[i]  

layerb<-brick(paste(getwd(),"/states.nc", sep=""), varname=layer)
layerb<-setZ(layerb, date, name="year")

layer_cr<-layerb[[1091:1166]]

writeRaster(layer_cr, paste(layer, "_1940a.tif", sep=""), overwrite=TRUE)
print(i)

}

```

```{r}
library(raster)
water<-raster("staticData_quarterdeg.nc", varname="icwtr")
writeRaster(water, "water_luh2.tif")

```

```{r}
#LPI<-read.csv("D:/Fiona/Git_Method/Git_Method/LPI_populations_IP_fishedit_20140310_nonconf.csv")
LPI<-read.csv("LPI_pops_20160523_edited.csv")

LPIsp<-subset(LPI, Specific_location==1 & System !="Marine" & Class != "Actinopterygii"& Class != "Cephalaspidomorphi" )

xy<-data.frame(LPIsp$Longitude, LPIsp$Latitude)
xy_df<-data.frame(LPIsp$Longitude, LPIsp$Latitude)

colnames(xy_df)<-c("lon", "lat")
coordinates(xy_df) <- c("lon", "lat")
proj4string(xy_df)<-("+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0")

head(xy_df)
```


```{r}
library(raster)

land_use_layers_tif = c("primf_1940a.tif", "primn_1940a.tif", "secdf_1940a.tif", "secdn_1940a.tif","pastr_1940a.tif","range_1940a.tif","urban_1940a.tif","c3ann_1940a.tif","c3per_1940a.tif","c4ann_1940a.tif","c4per_1940a.tif","c3nfx_1940a.tif", "water_luh2.tif")
land_use_result_names = c("primf_r.csv", "primn_r.csv","secdf_r.csv", "secdn_r.csv","pastr_r.csv","range_r.csv","urban_r.csv","c3ann_r.csv","c3per_r.csv","c4ann_r.csv","c4per_r.csv","c3nfx_r.csv", "water_r.csv")

```


```{r}

library(doParallel)
library(reshape2)

for (i in 1:length(land_use_layers_tif)) {
  layer = brick(land_use_layers_tif[i])
  
  n<-6  #number of cores to use - not sure how many I can go up to
  cl<-makeCluster(n)
  registerDoParallel(cl)  
  
  years<-nlayers(layer)    #splitting the data evenly between the cores
  step<-floor(years/n)
  
  ptime <- system.time({   
    df<- foreach(years, .combine=cbind) %dopar%{
      rasterex <- raster:::extract(layer[[1:years]], xy_df)
    }
  }) 
  ptime 
  stopCluster(cl)
  
  dates<-1940:2015
  
  datesr<-rep(dates, each=length(xy[,1]))
  
  dfm<-melt(df)
  
  lon<-xy[,1]
  lat<-xy[,2]
  
  dfm2<-cbind(lon,lat,datesr, dfm)
  write.csv(dfm2, land_use_result_names[i])
  print(land_use_layers_tif[i])
}
```

```{r}

primf2 <- read.csv("primf_r.csv")
primn2<-read.csv("primn_r.csv")
secdf2<-read.csv("secdf_r.csv")
secdn2<-read.csv("secdn_r.csv")
pastr2<-read.csv("pastr_r.csv")
range2<-read.csv("range_r.csv")
urban2<-read.csv("urban_r.csv")
c3ann2<-read.csv("c3ann_r.csv")
c3per2<-read.csv("c3per_r.csv")
c4ann2<-read.csv("c4ann_r.csv")
c4per2<-read.csv("c4per_r.csv")
c3nfx2<-read.csv("c3nfx_r.csv")
water2<-read.csv("water_r.csv")
  
land_use_nat<-data.frame(primf2$lon, primf2$lat, primf2$datesr, primf2$value, primn2$value,secdf2$value, secdn2$value, pastr2$value, range2$value, urban2$value, c3ann2$value, c3per2$value, c4ann2$value, c4per2$value, c3nfx2$value,water2$value)

colnames(land_use_nat)<-c("Longitude", "Latitude", "Year", "Primary_Forest", "Primary_Non_Forest", 
                          "Secondary_Forest", "Secondary_Non_Forest", "Pasture", "Rangeland", "Urban", "C3ann", "C3per", "C4ann", "C4per", "C3nfx", "Water_Ice") 

land_use_nat$total<-land_use_nat$Primary_Forest+land_use_nat$Primary_Non_Forest+land_use_nat$Secondary_Forest+
  land_use_nat$Secondary_Non_Forest+ land_use_nat$Pasture+land_use_nat$Rangeland+land_use_nat$Urban+land_use_nat$C3ann+land_use_nat$C3per+land_use_nat$C4ann+land_use_nat$C4per+land_use_nat$C3nfx+land_use_nat$Water_Ice

land_use_nat$crop<-land_use_nat$C3ann+land_use_nat$C3per+land_use_nat$C4ann+land_use_nat$C4per+land_use_nat$C3nfx

LPI_ID<-LPIsp[,c("ID", "Longitude", "Latitude")]

LPILU<-merge(LPI_ID,land_use_nat, by=c("Longitude", "Latitude"))

hist(LPILU$total, breaks=100)

#write.csv(LPILU, "LUH2_Land_Use_All_LPI.csv", overwrite=FALSE)
#write.csv(LPILU, "LUH2_Land_Use_All_moreLPI.csv")
#write.csv(LPILU, "LUH2_Land_Use_All_cats_moreLPI.csv")
write.csv(LPILU, "LUH2_Land_Use_All_cats_moreLPI_water.csv")
```

Step 5 - Calculating land use change for each population

```{r}
library(taRifx)

doDist = function(sp_name) {
  spid2 = subset(LPIsp, ID == sp_name)   #subsetting the population data by each population
  spid = spid2[,65:130]                     #subsetting only the dates
  colnames(spid)<-1950:2015              #renaming the date column names as R doesn't like numbered column names
  lu_id=subset(LPILU, ID == sp_name)  #subsetting the climate data by each population
  
  id<-spid2$ID
  Date<-as.numeric(colnames(spid))
  spidt<-destring(t(spid))
  
  if (sum(!is.na(spidt)) > 1) {
    Yr<-Date[min(which(!is.na(spidt))):max(which(!is.na(spidt)))]
    luyr<-as.matrix(subset(lu_id, Year>=min(Yr) & Year<= max(Yr))[,c(4:11,18)])   #6:11 for all categories 12:13 for nat vs anth
    luyr<-luyr[order(luyr[,1]),]
    nat<-luyr[,2]+luyr[,3]+luyr[,4]+luyr[,5]
    natdiff<-mean(diff(nat))
    
    lum<-matrix(luyr[,c(2:9)], nrow=length(Yr))
    m<-dist(lum, method="euclidean")
    n<-as.matrix(m)
    lu<-diag(n[c(2:nrow(n)),c(1:ncol(n))])
    euc<-mean(lu)
    
  } else{
   euc<-NA
    natdiff<-NA
  }
#  euc_df<-data.frame(id,euc)
euc_df<-data.frame(id,euc,natdiff)
 # euc_df<-data.frame(id, natdiff)
  print(euc_df)  
  return(euc_df)
}

all_df_list <- lapply(unique(LPIsp$ID), doDist)

all_matrix <- matrix(unlist(all_df_list), ncol=3, byrow=TRUE)
mean_df <- data.frame(all_matrix)
colnames(mean_df) <- c("ID", "LUC_dist", "Nat_change")

#write.csv(mean_df, "LUC_average_annual_change_nat_025.csv")
##write.csv(mean_df, "LUC_average_annual_change_nat_025_moreLPI.csv")
write.csv(mean_df, "LUC_average_mean_euc_dist_all_cat_nat_025_moreLPI.csv")

```

```{r}
# all_matrix <- matrix(unlist(all_df_list), ncol=3, byrow=TRUE)
# mean_df <- data.frame(all_matrix)
# colnames(mean_df) <- c("ID", "LUC_dist", "Nat_change")
# 
# 
# #write.csv(mean_df, "LUC_average_annual_change.csv")
# 
# write.csv(mean_df, "LUC_average_annual_change_nat_anth.csv")

```



Extracting Realm

```{r}
library(sp)

LPI<-read.csv("LPI_pops_20160523_edited.csv")

LPIsp<-subset(LPI, Specific_location==1 & System !="Marine" & Class != "Actinopterygii"& Class != "Cephalaspidomorphi" )

xy<-data.frame(LPIsp$Longitude, LPIsp$Latitude)
#xy<-data.frame(LPIsp$ID,LPIsp$Longitude, LPIsp$Latitude)
#xy<-unique(xy)     #identifying unique locations to extract climate data from 

xy_df<-data.frame(xy)
colnames(xy_df)<-c("lon", "lat")
coordinates(xy_df) <- c("lon", "lat")

head(xy_df)
proj4string(xy_df)<-CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")
xy_df$ID<-LPIsp$ID

```

```{r}
library(rgdal)
library(RQGIS)
library(spatialEco)


#ecoreg <- readOGR(dsn = "C:/Users/Fiona/Desktop/terr-ecoregions-TNC", layer = "tnc_terr_ecoregions") #desktop
ecoreg <- readOGR(dsn = "C:/Users/Fiona/Documents/GIS/Ecoregions" , layer = "tnc_terr_ecoregions")

pts.poly <- point.in.poly(xy_df,ecoreg)
head(pts.poly@data)


my_env <- set_env()

find_algorithms(search_term = "join", 
                qgis_env = my_env)

get_usage(alg= "qgis:joinattributesbylocation", qgis_env=my_env, intern=TRUE)

params <- get_args_man(alg = "qgis:joinattributesbylocation", 
                       qgis_env = my_env, options=TRUE)
params


params$TARGET<- ecoreg

params$JOIN<-xy_df

params$OUTPUT<-file.path(getwd(), "ecoreg_join.shp")

out <- run_qgis(alg = "qgis:joinattributesbylocation",
                params = params,
                load_output = params$OUTPUT,
                qgis_env = my_env)

```


Step 6 - Mixed Effects models exploring the impact of environmental change on population trends

```{r}
#temp<-read.csv("All_LPI_Mean_Temp_Slope.csv")
temp<-read.csv("All_LPI_Mean_Temp_Slope_nobuff.csv")
#temp<-read.csv("All_LPI_All_Years_Nobuff_1931.csv")
#temp<-read.csv("All_LPI_All_Years_Nobuff.csv")
body<-read.csv("bird_and_mammal_traits2.csv")
#luc<-read.csv("LUC_distance_all.csv") #start:end  #total change not just nat_loss
#luc<-read.csv("LUC_average_annual_change.csv") #annual
#luc<-read.csv("LUC_average_annual_change_nat_anth.csv") #annual nat vs anth and change in natural cover and with change in natural cover

luc<-read.csv("LUC_average_annual_change_nat_025.csv")#works/good results
#luc<-read.csv("LUC_average_annual_change_nat_025_moreLPI.csv")
luc2<-read.csv("LUC_average_mean_euc_dist_all_cat_nat_025_moreLPI.csv")
#LPI<-read.csv("LPI_populations_IP_fishedit_20140310_nonconf.csv")
LPI<-read.csv("LPI_pops_20160523_edited.csv")


#Realm<-read.csv("selected_pops_Ecoregion.csv")
Realm<-read.csv("Realm.csv", na.strings="")
Realm<-Realm[,c("ID", "WWF_REALM2")]
Realm2<-read.csv("hub_realms.csv")
colnames(Realm2)<-c("ID", "WWF_REALM2")

Realm3<-rbind(Realm,Realm2) #sort this has duplicates
Realm<-Realm[!is.na(Realm3$WWF_REALM2),]


#
pop<-read.csv("Global_Population_Trends_Rsq_Lambda_16_03_18.csv")
#EurHil<-read.csv("Europe_HILDA_5_year_pops.csv")  # data from Euro-centric analysis

temp<-temp[,c("ID", "Estimate")]

LPI<-LPI[,c("ID","Binomial","Common_name", "Order", "Protected_status", "Country","Region", "System", "Class","Specific_location", "Longitude", "Latitude", "Primary_threat", "Secondary_threat", "Tertiary_threat", "Migratory")]

df<-merge(merge(temp,luc2, by="ID", all=TRUE), merge(LPI, pop, by="ID", all=TRUE),by="ID", all=TRUE)

dfa<-merge(df, Realm, by="ID", all=TRUE)

dfb<-merge(dfa, body[,c(3:5)], by="ID", all=TRUE)     #41 pops bodysizes missing for birds

nrow(df)
nrow(dfa)

#
df2<-subset(dfb, !is.na(Estimate) & r_sq >= 0.4999999  & !is.na(Nat_change)&length_time >=5 & System!="Marine" &Specific_location == 1 & !is.na(Bodymass) &(Primary_threat!="Disease"& Primary_threat!="Exploitation"&Primary_threat!="Invasive spp/genes"&Primary_threat!="Pollution")) #& WWF_REALM2!="Palearctic")# & Migratory!=0)    #subset of r_sq >=0.5 not including a population where the value is 0.5 because of a rounding error - population 5458

nrow(df2)


#df2<-subset(dfb, !is.na(Estimate) & r_sq >= 0.4999999  & !is.na(LUC_dist) &length_time >=5 & System!="Marine" &Specific_location == 1 & !is.na(Bodymass)) #more populations with this?


#df2$Nat_loss<-0-df2$Nat_change   #so that higher numbers equate to a negative impact highervalue for nat loss = greater amount of'natural' habitat loss


df2[is.na(df2$lambda_mean),]$lambda_mean<-0

#####is this a problem - changing NAs for 0 - when the population is stationary across years the lambda mean is calculated

nrow(df2)

```

```{r}

plot(df2$LUC_dist, df2$Nat_change)
abline(v=0.01, h=0.005, col="red")
df3<-subset(df2, Primary_threat !="Climate change")


luc_threat<-subset(df3, (Nat_change>0.005|Nat_change <(-0.005) | (LUC_dist >0.01)))

write.csv(luc_threat, "Populations_main_threat_land_use_change.csv")

```


```{r}
library(ggplot2)
p<-ggplot(df2, aes(x=factor(Realm), y=Nat_change, colour=lambda_mean))
p+geom_jitter(width=0.5, size=2.5, alpha=0.6)+
  scale_colour_gradient(low = "red", high="green",name="Average\nLambda")+    #mid="grey"  #scale_colour_gradient2
  labs(x="Biogeographic Realm", y="Annual Change in Land Use")


df2$Population_change<-numeric(length(df2$ID))

df2[df2$lambda_mean >= log10(1.00),]$Population_change<- "Increasing"
df2[df2$lambda_mean <= log10(1.00),]$Population_change<- "Decreasing"

p<-ggplot(df2, aes(x=factor(Realm), y=Nat_change, colour=Population_change))
p+geom_jitter(width=0.5, size=2.5, alpha=0.6)+
  labs(x="Biogeographic Realm", y="Annual Change in Land Use")




```


```{r}
library(plyr)
#counting duplicates at each location
sp_dups<-data.frame(ddply(df2,.(Longitude,Latitude),nrow))
sp_dups$loc_id<-1:length(sp_dups$Longitude)
sp_dups_df<-merge(sp_dups, df2, by=c("Longitude","Latitude"))

library(data.table)
dt = as.data.table(sp_dups_df)

parm_df<-sp_dups_df[,c("ID","Estimate", "Nat_change")]  ##ID, land use, and climate  use "LUC_dist" or "Nat_change" for purely annual change in summed primary, secondary and other 

parm_mat<-as.matrix(parm_df)
parm_scale<-scale(parm_mat[,c("Estimate", "Nat_change")])       #use the scaling factors at the bottom of these to scale the rasters

centre_temp<-attr(parm_scale, 'scaled:center')[1]
centre_luc<-attr(parm_scale, 'scaled:center')[2]
scale_temp<-attr(parm_scale, 'scaled:scale')[1] 
scale_luc<-attr(parm_scale, 'scaled:scale')[2] 

parm_id<-parm_mat[,"ID"]

parm_df_scale<-data.frame(parm_id,parm_scale)

colnames(parm_df_scale)<-c("ID","mean_slope_scale", "change_rate_scale")

sp_df_scale<-merge(sp_dups_df, parm_df_scale, by="ID")

dt<-data.table(sp_df_scale)

#dt$lambda_mean[is.na(dt$lambda_mean)]<-0

range_lam<-tapply(dt$lambda_mean, dt$loc_id, range)
rl<-data.frame(matrix(unlist(range_lam), ncol=2, byrow=T))
rl$diff<-rl[,1] - rl[,2]
hist(rl$diff, main="range in lambda_mean within study sites")
#dt<-subset(dt, loc_id!=277)

range_body<-tapply(dt$Bodymass, dt$loc_id, range)
rl<-data.frame(matrix(unlist(range_body), ncol=2, byrow=T))
rl$diff<-rl[,1] - rl[,2]
hist(rl$diff, main="range in Bodymass within study sites")

rl$loc_id<-rownames(rl)
rl_bod2<-subset(rl, diff<(-2))

body_big<-dt[dt$loc_id %in% rl_bod2$loc_id,]
body_big2<-body_big[,c("ID","Bodymass")]

LPI_body<-body_big[body_big$ID%in% LPI$ID ,]
LPI_body_pop5<-subset(LPI_body, V1 >=5)


write.csv(LPI_body_pop5, "Populations_with_bodymass_range_5pops.csv")

```

ignore
```{r}
land<-seq(min(dt$change_rate_scale),max(dt$change_rate_scale),length.out=100)
temp<-seq(min(dt$mean_slope_scale),max(dt$mean_slope_scale),length.out=100)

landus<-(land  * scale_luc) + centre_luc
tempus<-(temp * scale_temp) + centre_temp

landus<-landus/sqrt(2) * 100    #so it is as a % pf land use change

dfus<-expand.grid(landus,tempus)
colnames(dfus)<-c("change_rate_scale", "mean_slope_scale")

```
ignore
```{r}
library(raster)
LU<-raster("Glob_LU_plot_1950_2005.tif")
TM<-raster("Glob_Slop_plot.tif")

LU_us<-(LU  - centre_luc )/scale_luc
TM_us<-(TM -centre_temp)/ scale_temp
LU_ust<-trim(LU_us)
LU_ust2<-resample(LU_ust,TM_us)

rc<-stack(TM_us,LU_ust2)

names(rc)<-c("mean_slope_scale","change_rate_scale")
rcm<-as.matrix(rc) 
rcmd<-data.frame(rcm)
```


```{r}


library(lme4)
library(MuMIn)
library(raster)
source("rsquaredglmm.R")

R=999
AIC_m0=numeric(R)
AIC_m0a= numeric(R)
AIC_m0b= numeric(R)
AIC_m0c= numeric(R)
AIC_m0d= numeric(R)
AIC_m1= numeric(R)
AIC_m1a= numeric(R)
AIC_m1b= numeric(R)
AIC_m1c= numeric(R)
AIC_mnull= numeric(R)

marg_Rsq_m0 = numeric(R)
marg_Rsq_m0a = numeric(R)
marg_Rsq_m0b = numeric(R)
marg_Rsq_m0c = numeric(R)
marg_Rsq_m0d = numeric(R)
marg_Rsq_m1 = numeric(R)
marg_Rsq_m1a = numeric(R)
marg_Rsq_m1b = numeric(R)
marg_Rsq_m1c = numeric(R)

cond_Rsq_m0 = numeric(R)
cond_Rsq_m0a = numeric(R)
cond_Rsq_m0b = numeric(R)
cond_Rsq_m0c = numeric(R)
cond_Rsq_m0d = numeric(R)
cond_Rsq_m1 = numeric(R)
cond_Rsq_m1a = numeric(R)
cond_Rsq_m1b = numeric(R)
cond_Rsq_m1c = numeric(R)
cond_Rsq_mnull = numeric(R)

m0_w = numeric(R)
m0a_w = numeric(R)
m0b_w = numeric(R)
m0c_w = numeric(R)
m0d_w = numeric(R)
m1_w = numeric(R)
m1a_w = numeric(R)
m1b_w = numeric(R)
m1c_w = numeric(R)
mnull_w = numeric(R)

MTC_i = numeric(R)
LUC_i = numeric(R)
BM_i = numeric(R)
LUC_MTC_i = numeric(R)

int_av = numeric(R)
MTC_av = numeric(R)
LUC_av = numeric(R)
BM_av = numeric(R)
LUC_MTC_av = numeric(R)

MTC_avus = numeric(R)
LUC_avus = numeric(R)

# sp_dups_df$mean_slope_scale<-sp_dups_df$Estimate
# sp_dups_df$change_rate_scale<-sp_dups_df$LUC_dist

for (i in 1:R) {
 dt2<-data.frame(dt[, ID[sample.int(.N, 1, replace=TRUE)], by = loc_id])     #.N     signifies the number of rows when using data.table
 colnames(dt2)[2]<-"ID"
  sp_dups_df2<-sp_df_scale[sp_df_scale$ID %in% dt2$ID,]    #sp_df_scale   #should be dt2

 
 m0<-lmer(lambda_mean ~ change_rate_scale+mean_slope_scale+change_rate_scale:mean_slope_scale+Bodymass+(1|Binomial),data=sp_dups_df2, REML=F)

 m0a<-lmer(lambda_mean ~ change_rate_scale+mean_slope_scale+Bodymass+(1|Binomial),data=sp_dups_df2, REML=F)

 m0b<-lmer(lambda_mean ~ change_rate_scale+Bodymass+(1|Binomial),data=sp_dups_df2, REML=F)

 m0c<-lmer(lambda_mean ~ mean_slope_scale+Bodymass+(1|Binomial),data=sp_dups_df2, REML=F)

 m0d<-lmer(lambda_mean ~ Bodymass+(1|Binomial),data=sp_dups_df2, REML=F)

  m1<-lmer(lambda_mean ~ change_rate_scale+mean_slope_scale+change_rate_scale:mean_slope_scale+(1|Binomial),data=sp_dups_df2, REML=F)
  
  m1a<-lmer(lambda_mean ~ change_rate_scale+mean_slope_scale+(1|Binomial),data=sp_dups_df2, REML=F)
  
  m1b<-lmer(lambda_mean ~ change_rate_scale+(1|Binomial),data=sp_dups_df2, REML=F)
  
  m1c<-lmer(lambda_mean ~ mean_slope_scale+(1|Binomial),data=sp_dups_df2, REML=F)
 
  mnull<-lmer(lambda_mean ~ 1+(1|Binomial),data=sp_dups_df2, REML=F)
  
  #AIC
  AIC_m0[i]<-AIC(m0)
  AIC_m0a[i]<-AIC(m0a)
  AIC_m0b[i]<-AIC(m0b)
  AIC_m0c[i]<-AIC(m0c)
  AIC_m0d[i]<-AIC(m0d)
  AIC_m1[i]<-AIC(m1)
  AIC_m1a[i]<-AIC(m1a)
  AIC_m1b[i]<-AIC(m1b)
  AIC_m1c[i]<-AIC(m1c)
  AIC_mnull[i]<-AIC(mnull)

  # #Weights

  #msAICc <- model.sel(m1,m1a,m1b,m1c,mnull)
  msAICc <- model.sel(m0,m0a,m0b,m0c,m0d,m1,m1a,m1b,m1c,mnull)
  msAICc$model<-rownames(msAICc)
  msAICc<-data.frame(msAICc)

  m0_w[i]<-subset(msAICc, model =="m0")$weight
  m1_w[i]<-subset(msAICc, model=="m1")$weight
  m0a_w[i]<-subset(msAICc, model=="m0a")$weight
  m0b_w[i]<-subset(msAICc, model=="m0b")$weight
  m0c_w[i]<-subset(msAICc, model=="m0c")$weight
  m0d_w[i]<-subset(msAICc, model=="m0d")$weight
  m1a_w[i]<-subset(msAICc, model=="m1a")$weight
  m1b_w[i]<-subset(msAICc, model=="m1b")$weight
  m1c_w[i]<-subset(msAICc, model=="m1c")$weight
  mnull_w[i]<-subset(msAICc, model=="mnull")$weight

  #Rsq
  #models_list<-list(m1,m1a,m1b,m1c,mnull)
  models_list<-list(m0,m0a,m0b,m0c,m0d,m1,m1a,m1b,m1c,mnull)
  modelsR<-lapply(models_list,rsquared.glmm)
  modelsRsq <- matrix(unlist(modelsR), ncol=6, byrow=T)
  #rownames(modelsRsq)<-c("m1","m1a","m1b","m1c","mnull")
  rownames(modelsRsq)<-c("m0","m0a","m0b","m0c","m0d","m1","m1a","m1b","m1c","mnull")

  
  marg_Rsq_m0[i]<-modelsRsq["m0",4]
  marg_Rsq_m0a[i]<-modelsRsq["m0a",4]
  marg_Rsq_m0b[i]<-modelsRsq["m0b",4]
  marg_Rsq_m0c[i]<-modelsRsq["m0c",4]
  marg_Rsq_m0d[i]<-modelsRsq["m0d",4]
  marg_Rsq_m1[i]<-modelsRsq["m1",4]
  marg_Rsq_m1a[i]<-modelsRsq["m1a",4]
  marg_Rsq_m1b[i]<-modelsRsq["m1b",4]
  marg_Rsq_m1c[i]<-modelsRsq["m1c",4]
  cond_Rsq_m0[i]<-modelsRsq["m0",5]
  cond_Rsq_m0a[i]<-modelsRsq["m0a",5]
  cond_Rsq_m0b[i]<-modelsRsq["m0b",5]
  cond_Rsq_m0c[i]<-modelsRsq["m0c",5]
  cond_Rsq_m0d[i]<-modelsRsq["m0d",5]
  cond_Rsq_m1[i]<-modelsRsq["m1",5]
  cond_Rsq_m1a[i]<-modelsRsq["m1a",5]
  cond_Rsq_m1b[i]<-modelsRsq["m1b",5]
  cond_Rsq_m1c[i]<-modelsRsq["m1c",5]
  cond_Rsq_mnull[i]<-modelsRsq["mnull",5]

  var_imp<-summary(model.avg(models_list))
  MTC_i[i]<-var_imp$importance["mean_slope_scale"]
  LUC_i[i]<-var_imp$importance["change_rate_scale"]
  LUC_MTC_i[i]<-var_imp$importance["change_rate_scale:mean_slope_scale"]
  BM_i[i]<-var_imp$importance["Bodymass"]

  int_av[i]<-var_imp$coefmat.subset["(Intercept)","Estimate"]
  MTC_av[i]<-var_imp$coefmat.subset["mean_slope_scale","Estimate"]
  LUC_av[i]<-var_imp$coefmat.subset["change_rate_scale","Estimate"]
  BM_av[i]<-var_imp$coefmat.subset["Bodymass", "Estimate"]
  LUC_MTC_av[i]<-var_imp$coefmat.subset["change_rate_scale:mean_slope_scale","Estimate"]
  
  #MTC_avus[i]<-(MTC_av[i] * scale_temp) + centre_temp
  #LUC_avus[i]<-(LUC_av[i] * scale_luc) + centre_luc
  
  mav<-model.avg(models_list)
  #pred<-predict(mav, dfus, re.form=NA)
  #pdf<-data.frame(dfus, pred)
  #pred2<-matrix(pred, ncol=length(landus), nrow=length(tempus), byrow=T)
  #image(land,temp,pred2)
  # head(pred2)
  # pras<-raster(pred2, xmn=min(landus), xmx=max(landus), ymn=min(tempus), ymx=max(tempus))
  # 
  #pred_pcnt<-((10^pred2) - 1)    #for lambda sum this is total population change, for lambda mean this is average annual rate of change
  #pcntras<-raster(pred_pcnt, xmn=min(landus), xmx=max(landus), ymn=min(tempus), ymx=max(tempus))
  
  # p3s <- predict(mav,rcmd,re.form=NA) 
  # 
  # p4s<-raster(matrix(p3s, nrow=280, ncol=720, byrow=T))
  # 
 # file_m<-paste("predict_", i,".tif" ,sep="")
  # file_pl<-paste("world_plot", i, ".tif", sep="")
 # writeRaster(pcntras, filename=file_m, overwrite=TRUE)
  # writeRaster(p4s, filename = file_pl, overwrite=TRUE)
  print(i)
}
```

ignore
```{r}
land<-seq(min(dt$Nat_loss),max(dt$Nat_loss),length.out=100)
temp<-seq(min(dt$mean_slope_scale),max(dt$mean_slope_scale),length.out=100)
body<-seq(min(dt$Bodymass),max(dt$Bodymass),length.out=100)

pr_dfx<-expand.grid(land, temp, dt$Binomial)

colnames(pr_dfx)<-c("change_rate_scale", "mean_slope_scale", "Binomial")
#prd<-predict(m1, pr_dfx)


p <- ggplot(sp_dups_df2, aes(x = sp_dups_df2$mean_slope_scale, y = sp_dups_df2$lambda_mean, colour = sp_dups_df2$Binomial)) +
  geom_point(size=3) +
  geom_line(aes(y = predict(m1b)),size=1) 
print(p)

```
ignore
```{r}
list<-list.files(path = getwd(), pattern = "predict.*\\.tif$")

br<-stack(list)

br_av<-mean(br)


#plot(br_av, xlab="Land Use Change Distance", ylab="Annual Mean Temperature Change", main="Total Population Change (%) - Birds")
#points(df2$LUC, df2$Estimate, col=df2$WWF_REALM2, pch=16)


#writeRaster(br_av, "Birds_and_Mammals_Prediction_Average_Raster_Lambda_mean_noclimbuff.tif", overwrite=TRUE)

```
ignore
```{r}
a<-seq(1:100)
b<-seq(1:100)
ab<-expand.grid(a,b)  
ab$c<-ab$Var1*ab$Var2
abm<-matrix(ab$c, ncol=length(a), nrow=length(b),byrow=F)
plot(raster(abm))

```
ignore
```{r}
library(ggplot2)

br_avp<-rasterToPoints(br_av)

br_av_df <- data.frame(br_avp)
colnames(br_av_df) <- c("Land_Use_Change", "Annual_Mean_Temperature_Change", "Population")

df2$LUC<-(df2$LUC/sqrt(2))*100
```
ignore
```{r}

library(ggplot2)

xydata<-data.frame(df2$LUC, df2$Estimate, df2$WWF_REALM2)
colnames(xydata)<-c("Land_Use", "Mean_Temp", "Realm")

ggplot(data=br_av_df, aes(y=Annual_Mean_Temperature_Change, x=Land_Use_Change)) +
geom_raster(aes(fill=Population)) +
geom_point(data=xydata, aes(x=Land_Use, y=Mean_Temp,colour=Realm),size=2) +
theme_bw() +
scale_fill_continuous("Average Annual \nPopulation Change (%)", low="black", high="white")+
theme(axis.title.x = element_text(size=16),
axis.title.y = element_text(size=16, angle=90),
axis.text.x = element_text(size=14),
axis.text.y = element_text(size=14),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
legend.position = "right",
legend.key = element_blank()
)+
labs(x="Land Use Change (%)", y="Annual Mean Temperature" *-Change~degree*C)

hist(df2$Estimate, breaks=100, xlab="Annual Mean Temperature " *Change~degree*C, main="")

hist(df2$LUC_dist/sqrt(2), breaks=100, xlab="Percentage Land Use Change", main="")
```
ignore
```{r}
plist<-list.files(path = getwd(), pattern = "world_plot.*\\.tif$")

plr<-stack(plist)

plr_av<-mean(plr)

```
ignore
```{r}
plr_av2<-(10^plr_av) - 1

extent(plr_av2)<-c(-180, 180, -56, 84)


plr_avp<-rasterToPoints(plr_av2)

plr_av_df <- data.frame(plr_avp)
colnames(plr_av_df) <- c("Longitude", "Latitude", "Population")

# xydata<-data.frame(df2$Longitude, df2$Latitude, df2$WWF_REALM2)
# colnames(xydata)<-c("Land_Use", "Mean_Temp", "Realm")

ggplot(data=plr_av_df, aes(y=Latitude, x=Longitude)) +
geom_raster(aes(fill=Population)) +
theme_bw() +
scale_fill_continuous(low="light grey", high="darkred")+
theme(axis.title.x = element_text(size=16),
axis.title.y = element_text(size=16, angle=90),
axis.text.x = element_text(size=14),
axis.text.y = element_text(size=14),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
legend.position = "right",
legend.key = element_blank()
)+
labs(x="Longitude", y="Latitude", colourbar= "Average Annual Population Change (%)")


```


```{r}
AIC_df<-data.frame(cbind(AIC_m0,AIC_m0a,AIC_m1,AIC_m1a,AIC_m0b,AIC_m0c,AIC_m0d, AIC_m1b, AIC_m1c, AIC_mnull))
#AIC_df<-data.frame((cbind(AIC_m1, AIC_m1a, AIC_m1b,AIC_m1c,AIC_mnull)))
colnames(AIC_df)<-c("LUC*MTC+BM","LUC+MTC+BM", "LUC*MTC", "LUC+MTC", "LUC+BM","MTC+BM", "BM", "LUC", "MTC", "Null_Model")
#colnames(AIC_df)<-c("LUC*MTC", "LUC+MTC", "LUC", "MTC", "Null_Model")


AIC_del<-AIC_df[,c(1:length(AIC_df)-1)] - AIC_df$Null_Model

colMeans(AIC_del)


par(las=2) #make x axis labels perpendicular to axis - model names
par(mar=c(10,5,1,1))
boxplot(AIC_del, ylab="Delta AIC from Null Model", xlab="")
#####mtext("Treatment:Geno", side=1, line=5)
abline(h=0, col="red", lty =2)

```

```{r}

#marg r squared
marg_df<- data.frame(cbind(marg_Rsq_m0,marg_Rsq_m0a,marg_Rsq_m1,marg_Rsq_m1a,marg_Rsq_m0b,marg_Rsq_m0c,marg_Rsq_m0d,marg_Rsq_m1b,marg_Rsq_m1c)*100)

colnames(marg_df)<-c("LUC*MTC+BM","LUC+MTC+BM", "LUC*MTC", "LUC+MTC", "LUC+BM","MTC+BM", "BM", "LUC", "MTC")

boxplot(marg_df, main="", ylab= "Marginal R Squared (%)")
```

```{r}
#cond r squared
cond_df<- data.frame(cbind(cond_Rsq_m0,cond_Rsq_m0a,cond_Rsq_m1,cond_Rsq_m1a,cond_Rsq_m0b,cond_Rsq_m0c,cond_Rsq_m0d,cond_Rsq_m1b,cond_Rsq_m1c,cond_Rsq_mnull)*100)
colnames(cond_df)<-c("LUC*MTC+BM","LUC+MTC+BM", "LUC*MTC", "LUC+MTC", "LUC+BM","MTC+BM", "BM", "LUC", "MTC", "Null Model")

boxplot(cond_df, ylab="Conditional R squared (%)")
```

```{r}
#model weight in averaged model
weight_df<-data.frame(cbind(m0_w,m0a_w,m1_w,m1a_w,m0b_w,m0c_w,m0d_w,m1b_w,m1c_w,mnull_w)*100)

colnames(weight_df)<-c("LUC*MTC+BM","LUC+MTC+BM", "LUC*MTC", "LUC+MTC", "LUC+BM","MTC+BM", "BM", "LUC", "MTC", "Null Model")

boxplot(weight_df, main="", ylab="Weight of model in averaged model (%)")
```


```{r}
#variable importance in averaged model
vi_df<-(data.frame(cbind(MTC_i,LUC_i,BM_i,LUC_MTC_i)))

colnames(vi_df)<-c("MTC", "LUC", "BM", "LUC*MTC")

boxplot(vi_df)

```


```{r}
par(mar=c(8,4.5,2,1))

Low<-(R+1)/40
High<-(R+1)-(R+1)/40 

mean_av<- c(mean(LUC_av),mean(MTC_av), mean(BM_av),mean(LUC_MTC_av))
lowCI_av<-c(sort(LUC_av)[Low], sort(MTC_av)[Low],sort(BM_av)[Low], sort(LUC_MTC_av)[Low])
highCI_av<-c(sort(LUC_av)[High], sort(MTC_av)[High],sort(BM_av)[High], sort(LUC_MTC_av)[High])

Variable<-c("Natural Cover \nLoss", "Mean Temp. \nChange",  "Bodymass", "Interaction")

conf_av<-data.frame(rbind( lowCI_av, mean_av, highCI_av))
colnames(conf_av)<-Variable
conf_av

library(plotrix)

plotCI(1:4, mean_av, (highCI_av-mean_av), (mean_av-lowCI_av), ylab="Coefficient (95% C.I.)", xlab="" ,xaxt = "n", 
       main="", lwd=1, ylim=c(min(lowCI_av*1.1), max(highCI_av*1.1)))
axis(1, at=1:4, labels=colnames(conf_av), las=2)
abline(h=0, col="red", lty =2)

```

```{r}
###plotting difference between interaction and null 
plot(AIC_m1, ylab="AIC value", xlab="Model Run", ylim=c(-320, -200))
points(AIC_mnull, col="red")

plot(AIC_m1 - AIC_mnull, main="Difference in AIC between Interacting and Null Model - Birds", ylab="Delta AIC", xlab="Model Run", )
abline(h=0, col="red", lty =2)

```

```{r}
#install.packages('ggthemes', dependencies = TRUE)

library(ggplot2)
library(ggthemes)
library(palettetown)
library(reshape2)

#AIC_df<-data.frame(AIC_m1, AIC_m1a, AIC_m1b, AIC_m1c, AIC_mnull)
colnames(AIC_del)<-c("AIC_m0","AIC_m0a","AIC_m0b","AIC_m0c","AIC_m0d","AIC_m1","AIC_m1a", "AIC_m1b", "AIC_m1c")
AIC_del2<-melt(AIC_del)
colnames(AIC_del2)<-c("Model", "AIC")

p<-ggplot(AIC_del2, aes(x=factor(Model), y=AIC, fill=factor(Model)))
p+geom_violin(trim=TRUE) +
xlab("Model")+
scale_fill_poke(pokemon = 'Vaporeon', spread = 9)


```

```{r}

mean_rsq<-c(mean(marg_Rsq_m1), mean(marg_Rsq_m1a), mean(marg_Rsq_m1b), mean(marg_Rsq_m1c))*100
low_rsq<-c(sort(marg_Rsq_m1)[Low], sort(marg_Rsq_m1a)[Low], sort(marg_Rsq_m1b)[Low], sort(marg_Rsq_m1c)[Low])*100
high_rsq<-c(sort(marg_Rsq_m1)[High], sort(marg_Rsq_m1a)[High], sort(marg_Rsq_m1b)[High], sort(marg_Rsq_m1c)[High])*100

Variable<-c("LUC*MTC", "LUC+MTC", "LUC", "MTC")

rsq_df<-data.frame(rbind(low_rsq, mean_rsq, high_rsq))
colnames(rsq_df)<-Variable


library(plotrix)

plotCI(1:4, mean_rsq, (high_rsq-mean_rsq), (mean_rsq-low_rsq), ylab="R squared value (%) (95% C.I.)", xlab="" ,xaxt = "n", 
       main="Distribution of R squared - Migratory Birds", lwd=1, ylim=c(min(low_rsq*1.01), max(high_rsq*0.99)))
axis(1, at=1:4, labels=colnames(rsq_df), las=2)



```

```{r}
w_av<- c(mean(m1_w),mean(m1a_w),mean(m1b_w), mean(m1c_w), mean(mnull_w))*100
low_w<-c(sort(m1_w)[Low], sort(m1a_w)[Low], sort(m1b_w)[Low], sort(m1c_w)[Low], sort(mnull_w)[Low])*100
high_w<-c(sort(m1_w)[High], sort(m1a_w)[High], sort(m1b_w)[High], sort(m1c_w)[High], sort(mnull_w)[High])*100

Variable<-c("LUC*MTC", "LUC+MTC", "LUC", "MTC", "Null")

conf_av<-data.frame(rbind(w_av, low_w, high_w))
colnames(conf_av)<-Variable
conf_av

library(plotrix)

plotCI(1:5, w_av, (high_w-w_av), (w_av-low_w), ylab="Model Weight Values (95% C.I.)", xlab="" ,xaxt = "n", 
       main="Distribution of Model Weight - Birds", lwd=1, ylim=c(min(low_w*1.01), max(high_w*1.01)))
axis(1, at=1:5, labels=colnames(conf_av), las=2)


```

```{r,eval=FALSE, echo=FALSE}
Low<-(R+1)/40
High<-(R+1)-(R+1)/40 


mean_avus<- c(mean(LUC_avus),mean(MTC_avus))
lowCI_avus<-c(sort(LUC_avus)[Low], sort(MTC_avus)[Low])
highCI_avus<-c(sort(LUC_avus)[High], sort(MTC_avus)[High])

Variable<-c("LUC", "MTC")

conf_avus<-data.frame(rbind(lowCI_avus, mean_avus, highCI_avus))
colnames(conf_avus)<-Variable
conf_avus

library(plotrix)

plotCI(1:2, mean_avus, (highCI_avus-mean_avus), (mean_avus-lowCI_avus), ylab="Coefficient (95% C.I.)", xlab="" ,xaxt = "n", 
       main="Variable Coefficients", lwd=1, ylim=c(min(lowCI_avus*1.1), max(highCI_avus*1.1)))
axis(1, at=1:2, labels=colnames(conf_avus), las=2)
abline(h=0, col="red", lty =2)

```

```{r,eval=FALSE, echo=FALSE}


m1<-lmer(lambda_mean ~ change_rate_scale+mean_slope_scale+change_rate_scale:mean_slope_scale+(1|Binomial),data=sp_df_scale, REML=F)
 
p3s <- predict(m1,rcmd,re.form=NA) 

p4s<-raster(matrix(p3s, nrow=280, ncol=720, byrow=T))

plot(p4s)
p5s<-(10^p4s) - 1
plot(p5s)
```


