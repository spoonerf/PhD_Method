---
title: "Global_Method"
author: "Fiona Spooner"
date: "23 March 2016"
output: html_document
---

Step 1 - Calculating Lambdas for each population
```{r}
library(plyr)
library(taRifx)
library(mgcv)
library(zoo)
```


```{r}

LPI<-read.csv("LPI_populations_IP_fishedit_20140310_nonconf.csv")

LPI_pop<-subset(LPI, Specific_location==1 & System !="Marine" & Class != "Actinopterygii"& Class != "Cephalaspidomorphi")

ID<-LPI_pop$ID
pop_data<- LPI_pop[,c(1,63:125)]

pop_datab <- (pop_data [,2:64] !="NULL")
points_per_pop1950_2012 = rowSums(pop_datab)
length_id <- data.frame(ID,points_per_pop1950_2012)

LPI_EU<-merge(length_id, LPI_pop, by = "ID")
LPI_EU<-subset(LPI_EU, points_per_pop1950_2012 >=2)

LPI_EU2<-LPI_EU[,c(1:3,64:126)]
LPI_EU2[LPI_EU2 == 'NULL'] = NA

```


```{r}
doFit = function(sp_name) {
  spid2 = subset(LPI_EU2, ID == sp_name)   #subsetting the population data by each population 
  spid = spid2[,4:66]                     #subsetting only the dates
  colnames(spid)<-1950:2012              #renaming the date column names as R doesn't like numbered column names
  
  name<-spid2$Binomial
  id<-spid2$ID
  points<-spid2$points_per_pop1950_2012
  name_id<-paste(name, id, sep="_") #creating id for naming files of plots
  Date<-as.numeric(colnames(spid))
  spidt<-destring(t(spid))
  time<-length(min(which(!is.na(spidt))):max(which(!is.na(spidt))))
  missing<-time-points
  
  Year<-Date[min(which(!is.na(spidt))):max(which(!is.na(spidt)))]
  Population<-spidt[min(which(!is.na(spidt))):max(which(!is.na(spidt)))]
  Population[Population == 0] <- mean(Population, na.rm=TRUE)*0.01 #if a population is zero one year thhis is replaced with 1% of the average population estimate - because you can log zeros
  
  df<-data.frame(Year,Population)
    
  
  if (points >=6) {           ###should I be trying GAMs for populations with less than six points and if that doesn't fit then use a linear model - here I am automatically fitting a linear model if there are less than six points
    PopN = log10(Population)
    if (length(na.omit(PopN)) >=6) {
      SmoothParm = round(length(na.omit(PopN))/2)    ####added na.omit in as was getting " A term has fewer unique covariate combinations than specified maximum degrees of freedom" error
    } else{
      SmoothParm=3
    }
#     mg1<-mgcv:::gam(Population ~ s(Year))
#     mg2<-mgcv:::gam(PopN ~ s(Year))
    mg2<-mgcv:::gam(PopN ~ s(Year, k=SmoothParm), fx=TRUE)
    pv2 <- predict(mg2,df,type="response",se=TRUE) 
    R_sq2<-summary(mg2)$r.sq
    model<-1
    pv2$fit[pv2$fit <= 0] <- NA
    lambda2<-diff(pv2$fit)
    lambda_sum2<-sum(lambda2, na.rm=TRUE)
    lambda_mean2<-mean(lambda2, na.rm=TRUE)
 
  } else {
    SmoothParm<-NA
    PopN = log10(Population)
    ml2<-lm(PopN~df$Year)
    R_sq2<-summary(ml2)$r.sq
    model<-0
    Pop_interp2<-na.approx(PopN)
    Pop_interp2[Pop_interp2<=0] <- NA
    lambda2<-diff(Pop_interp2)
    lambda_sum2<-sum(lambda2, na.rm=TRUE)
    lambda_mean2<-mean(lambda2, na.rm=TRUE)
  }

res_df = data.frame(sp_name=sp_name, points=points, SmoothParm=SmoothParm, r_sq=R_sq2, model=model,lambda_sum=lambda_sum2,lambda_mean=lambda_mean2,time=time, missing=missing)

print(res_df)
return(res_df)
}

all_df_list <- lapply(unique(LPI_EU2$ID), doFit)

```

```{r}
all_matrix <- matrix(unlist(all_df_list, use.names =FALSE), ncol=9, byrow=TRUE)
all_df <- data.frame(all_matrix)
colnames(all_df) <- c("ID", "points","SmoothParm", "r_sq", "model", "lambda_sum","lambda_mean", "length_time", "missing_years")

write.csv(all_df, "Global_Population_Trends_Rsq_Lambda_16_03_18.csv")
```

Step 2 - Extracting the Climate data for each population

```{r}
library(raster)
library(doParallel)
library(beepr)
library(lubridate)
library(reshape2)

```

```{r}
CR30s<-brick("D:/Fiona/Git_Method/Git_Method/cru_ts3.23.1931.1940.tmp.dat.nc")
CR40s<-brick("D:/Fiona/PhD1/Climate/Global/cru_ts3.23.1941.1950.tmp.dat.nc/cru_ts3.23.1941.1950.tmp.dat.nc")
CR50s<-brick("D:/Fiona/PhD1/Climate/Global/cru_ts3.23.1951.1960.tmp.dat.nc/cru_ts3.23.1951.1960.tmp.dat.nc")
CR60s<-brick("D:/Fiona/PhD1/Climate/Global/cru_ts3.23.1961.1970.tmp.dat.nc/cru_ts3.23.1961.1970.tmp.dat.nc")
CR70s<-brick("D:/Fiona/PhD1/Climate/Global/cru_ts3.23.1971.1980.tmp.dat.nc/cru_ts3.23.1971.1980.tmp.dat.nc")
CR80s<-brick("D:/Fiona/PhD1/Climate/Global/cru_ts3.23.1981.1990.tmp.dat.nc/cru_ts3.23.1981.1990.tmp.dat.nc")
CR90s<-brick("D:/Fiona/PhD1/Climate/Global/cru_ts3.23.1991.2000.tmp.dat.nc/cru_ts3.23.1991.2000.tmp.dat.nc")
CR00s<-brick("D:/Fiona/PhD1/Climate/Global/cru_ts3.23.2001.2010.tmp.dat.nc/cru_ts3.23.2001.2010.tmp.dat.nc")
CR10s<-brick("D:/Fiona/PhD1/Climate/Global/cru_ts3.23.2011.2014.tmp.dat.nc/cru_ts3.23.2011.2014.tmp.dat.nc")

plot(CR40s[[11]])
```


```{r}
LPI<-read.csv("D:/Fiona/Git_Method/Git_Method/LPI_populations_IP_fishedit_20140310_nonconf.csv")

LPIsp<-subset(LPI, Specific_location==1 & System !="Marine" & Class != "Actinopterygii"& Class != "Cephalaspidomorphi" )

CR<-stack(CR30s,CR40s,CR50s,CR60s,CR70s,CR80s,CR90s,CR00s,CR10s)

plot(CR[[1]])
points(LPIsp$Longitude, LPIsp$Latitude)

xy<-data.frame(LPIsp$Longitude, LPIsp$Latitude)

xy<-unique(xy)     #identifying unique locations to extract climate data from 

xy_df<-data.frame(xy)
colnames(xy_df)<-c("lon", "lat")
coordinates(xy_df) <- c("lon", "lat")

length(xy_df)

```

```{r}

n<-6#number of cores to use - not sure how many I can go up to - 6 at UCL
cl<-makeCluster(n)
registerDoParallel(cl)  
getDoParWorkers()

buff<- function (year,b)  {
  
  rasterex<-raster:::extract(CR[[year]], xy_df, buff=b, fun=mean, na.rm=TRUE)
  return(rasterex)
  
}

```

```{r}
diam<-0 #size of buffer to use - in metres
lyr<-1:nlayers(CR)


stime <- system.time({
  sr <- foreach(1, .combine = cbind) %dopar% mapply(buff,lyr,diam)
})
stime
beep(3)

stopCluster(cl)

```

```{r}

dates<-seq(ymd('1931-01-16'),ymd('2014-12-16'), by = 'months')


datesr<-rep(dates, each=1078)

srm<-melt(sr)

lon<-xy[,1]
lat<-xy[,2]

srm2<-cbind(lon,lat,datesr, srm)

srm3<-srm2[,c(1,2,3,6)]

colnames(srm3)<-c("Longitude", "Latitude", "Date", "Mean_T")

LPI_ID<-LPIsp[,c("ID", "Longitude", "Latitude")]

LPIclim<-merge(srm3, LPI_ID, by=c("Longitude", "Latitude"))

write.csv(LPIclim, "Global_Mean_Temp_All_LPI_nobuff_1931.csv")

```

Step 3 - Calculating mean temp change for each population

```{r}

#LPIclim<-read.csv("Global_Mean_Temp_All_LPI.csv")
LPIclim<-read.csv("Global_Mean_Temp_All_LPI_nobuff.csv")
LPIclim<-read.csv("Global_Mean_Temp_All_LPI_nobuff_1931.csv")

LPIclim$Date<-as.Date(LPIclim$Date, "%Y-%m-%d")
LPIclim$Year<-format(LPIclim$Date, "%Y")

LPI<-read.csv("LPI_populations_IP_fishedit_20140310_nonconf.csv")

LPIsp<-subset(LPI, Specific_location==1 & System !="Marine" & Class != "Actinopterygii"& Class != "Cephalaspidomorphi" & ID !=4438)

```

```{r}
library(broom)
library(plyr)
library(taRifx)
```

```{r}
lag<-0 #number of years before start date of pop recordes which i want climate data from

doMean = function(sp_name) {
  spid2 = subset(LPIsp, ID == sp_name)   #subsetting the population data by each population
  spid = spid2[,63:125]                     #subsetting only the dates
  rep ("NULL", 10)
  nid<-matrix(rep (NA, 10), nrow=1)                
  colnames(nid)<-1940:1949
  colnames(spid)<-1950:2012
  spid<-cbind(nid, spid)#renaming the date column names as R doesn't like numbered column names
  climid=subset(LPIclim, ID == sp_name)  #subsetting the climate data by each population
  
  year_temp <- ddply(climid, "Year", summarise,          #calculating the annual mean for max temp, min temp and precipitation
                     mean_mean = mean(na.omit(Mean_T)))
  name<-spid2$Binomial
  id<-spid2$ID
  points<-spid2$points_per_pop1950_2012
  name_id<-paste(name, id, sep="_") #creating id for naming files of plots
  Date<-as.numeric(colnames(spid))
  spidt<-destring(t(spid))

  Year<-Date[(min(which(!is.na(spidt)))-lag):max(which(!is.na(spidt)))]
  Population<-spidt[min(which(!is.na(spidt))):max(which(!is.na(spidt)))]

  Mean<-year_temp$mean_mean[(min(which(!is.na(spidt)))-lag):max(which(!is.na(spidt)))]
  # 
  Mean_mon<-climid[climid$Year %in% Year, ]$Mean_T
  year_temp$Year<-as.numeric(year_temp$Year)
  

  # Mean_mon<-climid[climid$Year %in% Year, ]
  # Mean_mon<-Mean_mon[order(as.Date(Mean_mon$Date, format="%Y/%m/%d")),]
  # plot(Mean_mon$Date, Mean_mon$Mean_T, type="l", xlab="Year", ylab="Degrees Celsius", main="Monthly Mean Temperature")
 # abline(lm(Mean_mon$Mean_T~Mean_mon$Date), col="red")
  
  if (sum(is.nan(Mean))!=length(Mean)){
    
    lm_mean<-lm(Mean~Year)
    #lm_mean<-lm(year_temp$mean_mean~year_temp$Year)
    lm_mean_df<-tidy(lm_mean)[2,]  
    mean_df<-cbind(id,lm_mean_df)
    
  } else{
    
    mean_df<-matrix(c(id,NA,NA,NA,NA,NA), nrow=1, ncol=6)
    colnames(mean_df)<-c("id", "term", "estimate", "std.error", "statistic", "p.value")
    mean_df<-data.frame(mean_df)
  }
  
  print(mean_df)  
  return(mean_df)
}

all_df_list <- lapply(unique(LPIsp$ID), doMean)
```

```{r}
all_matrix <- matrix(unlist(all_df_list), ncol=6, byrow=TRUE)
mean_df <- data.frame(all_matrix)
colnames(mean_df) <- c("ID", "Term","Estimate","SE","Statistic","p.val")

mean_df$Estimate<-as.numeric(as.character(mean_df$Estimate))

#write.csv(mean_df, "All_LPI_Mean_Temp_Slope_nobuff.csv")
#write.csv(mean_df, "All_LPI_All_Years_Nobuff.csv")
write.csv(mean_df, "All_LPI_All_Years_Nobuff_1931.csv")
```


Step 4 - Extracting Land Use Change Data for each population

```{r}
library(raster)

```

```{r}
crop<-brick("LUHa_u2t1.v1_gcrop.nc4")
prim<-brick("LUHa_u2t1.v1_gothr.nc4")
past<-brick("LUHa_u2t1.v1_gpast.nc4")
secd<-brick("LUHa_u2t1.v1_gsecd.nc4")
urban<-brick("LUHa_u2t1.v1_gurbn.nc4")


cropn<-crop[[251:306]]   #pulling out the data for 1950-2005 as the data starts at 1700
primn<-prim[[251:306]]
pastn<-past[[251:306]]
secdn<-secd[[251:306]]
urbann<-urban[[251:306]]

writeRaster(cropn, "Crop_1950.tif")
writeRaster(primn, "Prim_1950.tif")
writeRaster(pastn, "Past_1950.tif")
writeRaster(secdn, "Secd_1950.tif")
writeRaster(urbann, "Urbn_1950.tif")

cropn<-brick("Crop_1950.tif")
primn<-brick("Prim_1950.tif")
pastn<-brick("Past_1950.tif")
secdn<-brick("Secd_1950.tif")
urbn<-brick("Urbn_1950.tif")

```

```{r}
LPI<-read.csv("D:/Fiona/Git_Method/Git_Method/LPI_populations_IP_fishedit_20140310_nonconf.csv")

LPIsp<-subset(LPI, Specific_location==1 & System !="Marine" & Class != "Actinopterygii"& Class != "Cephalaspidomorphi" )

xy<-data.frame(LPIsp$Longitude, LPIsp$Latitude)

xy<-unique(xy)     #identifying unique locations to extract climate data from 

xy_df<-data.frame(xy)
colnames(xy_df)<-c("lon", "lat")
coordinates(xy_df) <- c("lon", "lat")

head(xy_df)
```

```{r}
library(doParallel)
library(beepr)
library(reshape2)
```

```{r}
layer<-urbn

n<-2  #number of cores to use - not sure how many I can go up to
cl<-makeCluster(n)
registerDoParallel(cl)  

days<-nlayers(layer)    #splitting the data evenly between the cores
step<-floor(days/n)

ptime <- system.time({   
  df<- foreach(days, .combine=cbind) %dopar%{
    rasterex <- raster:::extract(layer[[1:days]], xy_df)
  }
}) 
ptime 
#beep(3)
stopCluster(cl)

dates<-1950:2005

datesr<-rep(dates, each=1078)

dfm<-melt(df)

lon<-xy[,1]
lat<-xy[,2]

#dfm2<-cbind(lon,lat,datesr, dfm)
dfm2<-cbind(lon,lat,dates, dfm)
```

```{r}
#crop2<-dfm2   #do each individually
#prim2<-dfm2
#past2<-dfm2
#secdn2<-dfm2
#urbn2<-dfm2

land_use<-data.frame(crop2$lon, crop2$lat, crop2$datesr, crop2$value, prim2$value, past2$value, secdn2$value, urbn2$value)

colnames(land_use)<-c("Longitude", "Latitude","Year", "Crop", "Primary", "Pasture", "Secondary", "Urban")

LPI_ID<-LPIsp[,c("ID", "Longitude", "Latitude")]

LPILU<-merge(LPI_ID,land_use, by=c("Longitude", "Latitude"))

```

Ibex example
```{r}
LPILU<-subset(LPILU, Year >=1950 & Year <=1984)
euc<-numeric(nrow(LPILU-1))
for (i in 2:nrow(LPILU)){
  euc[i]<-dist(as.matrix(LPILU[c(i-1,i),c(5:9)]))
  print(i)
  }
  
years<-1950:1984

plot(years,euc, type="l", ylab="Land Use Change", xlab="Year", main="Annual Land Use Change")


```


```{r}
sums<-rowSums(LPILU[,c(5:9)])
hist(sums)

LPILU$Other<- 1 - rowSums(LPILU[,c(5:9)])  #not all cells add up to 1 - not sure why -water!
 
write.csv(LPILU, "Global_Land_Use_All_LPI.csv")

```

Step 5 - Calculating land use change for each population

```{r}
LPILU<-read.csv("Global_Land_Use_All_LPI.csv") 
#should probablyy get rid of those with high "other" category as may be reflective of crappy data

LPI<-read.csv("LPI_populations_IP_fishedit_20140310_nonconf.csv")

LPIsp<-subset(LPI, Specific_location==1 & System !="Marine" & Class != "Actinopterygii"& Class != "Cephalaspidomorphi" )

LPILU$Anth<-LPILU$Crop + LPILU$Pasture + LPILU$Urban
LPILU$Nat<-LPILU$Primary + LPILU$Secondary + LPILU$Other

```

```{r}
  
library(taRifx)

doDist = function(sp_name) {
  spid2 = subset(LPIsp, ID == sp_name)   #subsetting the population data by each population
  spid = spid2[,63:118]                     #subsetting only the dates
  colnames(spid)<-1950:2005              #renaming the date column names as R doesn't like numbered column names
  lu_id=subset(LPILU, ID == sp_name)  #subsetting the climate data by each population
 
  id<-spid2$ID
  Date<-as.numeric(colnames(spid))
  spidt<-destring(t(spid))
  
  if (sum(!is.na(spidt)) > 1) {
    Yr<-Date[min(which(!is.na(spidt))):max(which(!is.na(spidt)))]
    luyr<-as.matrix(subset(lu_id, Year>=min(Yr) & Year<= max(Yr))[,c(12:13)])   #6:11 for all categories 12:13 for nat vs anth
    natdiff<-mean(diff(luyr[,2]))
    
    lum<-matrix(luyr, ncol=ncol(luyr))
    m<-dist(lum, method="euclidean")
    n<-as.matrix(m)
    lu<-diag(n[c(2:nrow(n)),c(1:ncol(n))])
    euc<-mean(lu)

  } else{
    euc<-NA
    natdiff<-NA
  }
  #euc_df<-data.frame(id,euc)
  euc_df<-data.frame(id,euc,natdiff)
  print(euc_df)  
  return(euc_df)
}

all_df_list <- lapply(unique(LPIsp$ID), doDist)

```

```{r}
library(reshape)
library(ggplot2)

lu_id<- lu_id[ order(lu_id[,5]), ]

lu_id<-subset(lu_id, Year >= 1956 & Year <= 2000)

lu_df<-melt(lu_id[,c(6:11)])
lu_df2<-cbind(lu_id$Year, lu_df)
colnames(lu_df2)<-c("Year", "Land_Use_Type", "Percentage_Cover")

ggplot(data=lu_df2, aes(x=Year, y=Percentage_Cover, group=Land_Use_Type)) +
  geom_line(aes(color=Land_Use_Type))+
  geom_point(aes(color=Land_Use_Type))+
  labs(title="Land Use Cover Over Time",x="Year", y = "Percentage Cover")+
  theme(legend.title=element_blank())


```

```{r}
all_matrix <- matrix(unlist(all_df_list), ncol=3, byrow=TRUE)
mean_df <- data.frame(all_matrix)
colnames(mean_df) <- c("ID", "LUC_dist", "Nat_change")


#write.csv(mean_df, "LUC_average_annual_change.csv")

write.csv(mean_df, "LUC_average_annual_change_nat_anth.csv")

```

Step 6 - Mixed Effects models exploring the impact of environmental change on population trends

```{r}
#temp<-read.csv("All_LPI_Mean_Temp_Slope.csv")
temp<-read.csv("All_LPI_Mean_Temp_Slope_nobuff.csv")
#temp<-read.csv("All_LPI_All_Years_Nobuff_1931.csv")
#temp<-read.csv("All_LPI_All_Years_Nobuff.csv")
body<-read.csv("bird_and_mammal_traits2.csv")
#luc<-read.csv("LUC_distance_all.csv") #start:end
#luc<-read.csv("LUC_average_annual_change.csv") #annual
#luc<-read.csv("LUC_average_annual_change_nat_anth.csv") #annual nat vs anth and change in natural cover and with change in natural cover
luc<-read.csv("LUC_average_annual_change_nat_025.csv")
LPI<-read.csv("LPI_populations_IP_fishedit_20140310_nonconf.csv")


Realm<-read.csv("selected_pops_Ecoregion.csv")
Realm<-Realm[,c("ID", "WWF_REALM2")]

pop<-read.csv("Global_Population_Trends_Rsq_Lambda_16_03_18.csv")
EurHil<-read.csv("Europe_HILDA_5_year_pops.csv")  # data from Euro-centric analysis

temp<-temp[,c("ID", "Estimate")]

LPI<-LPI[,c("ID","Binomial","Common_name", "Order", "Protected_status", "Country","Region", "System", "Class","Specific_location", "Longitude", "Latitude", "Primary_threat", "Secondary_threat", "Tertiary_threat", "Migratory")]

df<-merge(merge(temp,luc, by="ID", all=TRUE), merge(LPI, pop, by="ID", all=TRUE),by="ID", all=TRUE)

df<-merge(df, Realm, by="ID")

df<-merge(df, body[,c(3:5)], by="ID", all=TRUE)     #41 pops bodysizes missing for birds

nrow(df)

df2<-subset(df, !is.na(Estimate)&r_sq >= 0.5  & !is.na(Nat_change)&length_time >=10 & System!="Marine" &Specific_location == 1 & (Class=="Aves") & !is.na(Bodymass) & Migratory ==0)

nrow(df2)

df2$Nat_loss<-0-df2$Nat_change   #so that higher numbers equate to a negative impact highervalue for nat loss = greater amount of'natural' habitat loss

```

```{r}
library(plyr)
#counting duplicates at each location
sp_dups<-data.frame(ddply(df2,.(Longitude,Latitude),nrow))
sp_dups$loc_id<-1:length(sp_dups$Longitude)
sp_dups_df<-merge(sp_dups, df2, by=c("Longitude","Latitude"))

library(data.table)
#dt = as.data.table(sp_dups_df)

parm_df<-sp_dups_df[,c("ID","Estimate", "Nat_loss")]  ##ID, land use, and climate  use "LUC_dist" or "Nat_change" for purely annual change in summed primary, secondary and other 

parm_mat<-as.matrix(parm_df)
parm_scale<-scale(parm_mat[,c("Estimate", "Nat_loss")])       #use the scaling factors at the bottom of these to scale the rasters

centre_temp<-attr(parm_scale, 'scaled:center')[1]
centre_luc<-attr(parm_scale, 'scaled:center')[2]
scale_temp<-attr(parm_scale, 'scaled:scale')[1] 
scale_luc<-attr(parm_scale, 'scaled:scale')[2] 

parm_id<-parm_mat[,"ID"]

parm_df_scale<-data.frame(parm_id,parm_scale)

colnames(parm_df_scale)<-c("ID","mean_slope_scale", "change_rate_scale")

sp_df_scale<-merge(sp_dups_df, parm_df_scale, by="ID")

dt<-data.table(sp_df_scale)

length(subset(dt,lambda_mean == NA))

#dt$lambda_mean[is.na(dt$lambda_mean)]<-0

range_lam<-tapply(dt$lambda_mean, dt$loc_id, range)
rl<-data.frame(matrix(unlist(range_lam), ncol=2, byrow=T))
rl$diff<-rl[,1] - rl[,2]
hist(rl$diff)
#dt<-subset(dt, loc_id!=277)

sp_df_scale[is.na(sp_df_scale$lambda_mean),]$lambda_mean<-0  #####is this a problem?

```

```{r}
land<-seq(min(dt$change_rate_scale),max(dt$change_rate_scale),length.out=100)
temp<-seq(min(dt$mean_slope_scale),max(dt$mean_slope_scale),length.out=100)

landus<-(land  * scale_luc) + centre_luc
tempus<-(temp * scale_temp) + centre_temp

landus<-landus/sqrt(2) * 100    #so it is as a % pf land use change

dfus<-expand.grid(landus,tempus)
colnames(dfus)<-c("change_rate_scale", "mean_slope_scale")


```

```{r}
LU<-raster("Glob_LU_plot_1950_2005.tif")
TM<-raster("Glob_Slop_plot.tif")

LU_us<-(LU  - centre_luc )/scale_luc
TM_us<-(TM -centre_temp)/ scale_temp
LU_ust<-trim(LU_us)
LU_ust2<-resample(LU_ust,TM_us)

rc<-stack(TM_us,LU_ust2)

names(rc)<-c("mean_slope_scale","change_rate_scale")
rcm<-as.matrix(rc) 
rcmd<-data.frame(rcm)
```

```{r}


library(lme4)
library(MuMIn)
library(raster)
source("rsquaredglmm.R")

R=499
AIC_m0=numeric(R)
AIC_m1= numeric(R)
AIC_m1a= numeric(R)
AIC_m1b= numeric(R)
AIC_m1c= numeric(R)
AIC_mnull= numeric(R)

marg_Rsq_m0 = numeric(R)
marg_Rsq_m1 = numeric(R)
marg_Rsq_m1a = numeric(R)
marg_Rsq_m1b = numeric(R)
marg_Rsq_m1c = numeric(R)

cond_Rsq_m0 = numeric(R)
cond_Rsq_m1 = numeric(R)
cond_Rsq_m1a = numeric(R)
cond_Rsq_m1b = numeric(R)
cond_Rsq_m1c = numeric(R)
cond_Rsq_mnull = numeric(R)

m0_w = numeric(R)
m1_w = numeric(R)
m1a_w = numeric(R)
m1b_w = numeric(R)
m1c_w = numeric(R)
mnull_w = numeric(R)

MTC_i = numeric(R)
LUC_i = numeric(R)
LUC_MTC_i = numeric(R)

int_av = numeric(R)
MTC_av = numeric(R)
LUC_av = numeric(R)
LUC_MTC_av = numeric(R)

MTC_avus = numeric(R)
LUC_avus = numeric(R)

# sp_dups_df$mean_slope_scale<-sp_dups_df$Estimate
# sp_dups_df$change_rate_scale<-sp_dups_df$LUC_dist

for (i in 1:R) {
 dt2<-data.frame(dt[, ID[sample.int(.N, 1, TRUE)], by = loc_id])     #.N     signifies the number of rows when using data.table
 #dt2<-dt[sample(nrow(dt), 150, replace=TRUE), ]
  
 colnames(dt2)[2]<-"ID"
  sp_dups_df2<-sp_df_scale[sp_df_scale$ID %in% dt2$ID,]    #sp_df_scale   #should be dt2

 
  m0<-lmer(lambda_mean ~ change_rate_scale+mean_slope_scale+change_rate_scale:mean_slope_scale+Bodymass+(1|Binomial),data=sp_dups_df2, REML=F)
  
  m1<-lmer(lambda_mean ~ change_rate_scale+mean_slope_scale+change_rate_scale:mean_slope_scale+(1|Binomial),data=sp_dups_df2, REML=F)
  m1T<-lmer(lambda_mean ~ change_rate_scale+mean_slope_scale+change_rate_scale:mean_slope_scale+(1|Binomial),data=sp_dups_df2)
  
  m1a<-lmer(lambda_mean ~ change_rate_scale+mean_slope_scale++(1|Binomial),data=sp_dups_df2, REML=F)
  m1aT<-lmer(lambda_mean ~ change_rate_scale+mean_slope_scale+(1|Binomial),data=sp_dups_df2)
  
  m1b<-lmer(lambda_mean ~ change_rate_scale+(1|Binomial),data=sp_dups_df2, REML=F)
  m1bT<-lmer(lambda_mean ~ change_rate_scale+(1|Binomial),data=sp_dups_df2)
  
  m1c<-lmer(lambda_mean ~ mean_slope_scale+(1|Binomial),data=sp_dups_df2, REML=F)
  m1cT<-lmer(lambda_mean ~ mean_slope_scale+(1|Binomial),data=sp_dups_df2)
  
  mnull<-lmer(lambda_mean ~ 1+(1|Binomial),data=sp_dups_df2, REML=F)
  mnullT<-lmer(lambda_mean ~ 1+(1|Binomial),data=sp_dups_df2)

  #AIC
  AIC_m0[i]<-AIC(m0)
  AIC_m1[i]<-AIC(m1)
  AIC_m1a[i]<-AIC(m1a)
  AIC_m1b[i]<-AIC(m1b)
  AIC_m1c[i]<-AIC(m1c)
  AIC_mnull[i]<-AIC(mnull)

  # #Weights

  msAICc <- model.sel(m0,m1,m1a,m1b,m1c,mnull)
  msAICc$model<-rownames(msAICc)
  msAICc<-data.frame(msAICc)

  m0_w[i]<-subset(msAICc, model =="m0")$weight
  m1_w[i]<-subset(msAICc, model=="m1")$weight
  m1a_w[i]<-subset(msAICc, model=="m1a")$weight
  m1b_w[i]<-subset(msAICc, model=="m1b")$weight
  m1c_w[i]<-subset(msAICc, model=="m1c")$weight
  mnull_w[i]<-subset(msAICc, model=="mnull")$weight

  #Rsq
  models_list<-list(m0,m1,m1a,m1b,m1c,mnull)
  modelsR<-lapply(models_list,rsquared.glmm)
  modelsRsq <- matrix(unlist(modelsR), ncol=6, byrow=T)

  marg_Rsq_m0[i]<-modelsRsq[1,4]
  marg_Rsq_m1[i]<-modelsRsq[2,4]
  marg_Rsq_m1a[i]<-modelsRsq[3,4]
  marg_Rsq_m1b[i]<-modelsRsq[4,4]
  marg_Rsq_m1c[i]<-modelsRsq[5,4]
  cond_Rsq_m0[i]<-modelsRsq[1,5]
  cond_Rsq_m1[i]<-modelsRsq[2,5]
  cond_Rsq_m1a[i]<-modelsRsq[3,5]
  cond_Rsq_m1b[i]<-modelsRsq[4,5]
  cond_Rsq_m1c[i]<-modelsRsq[5,5]
  cond_Rsq_mnull[i]<-modelsRsq[6,5]

  var_imp<-summary(model.avg(models_list))
  # MTC_i[i]<-var_imp$importance["mean_slope_scale"]
  # LUC_i[i]<-var_imp$importance["change_rate_scale"]
  # LUC_MTC_i[i]<-var_imp$importance["change_rate_scale:mean_slope_scale"]
  # #BM_i[i]<-var_imp$importance["Bodymass"]

  int_av[i]<-var_imp$coefmat.subset["(Intercept)","Estimate"]
  MTC_av[i]<-var_imp$coefmat.subset["mean_slope_scale","Estimate"]
  LUC_av[i]<-var_imp$coefmat.subset["change_rate_scale","Estimate"]
  LUC_MTC_av[i]<-var_imp$coefmat.subset["change_rate_scale:mean_slope_scale","Estimate"]
  
  #MTC_avus[i]<-(MTC_av[i] * scale_temp) + centre_temp
  #LUC_avus[i]<-(LUC_av[i] * scale_luc) + centre_luc
  
  mav<-model.avg(models_list)
  #pred<-predict(mav, dfus, re.form=NA)
  #pdf<-data.frame(dfus, pred)
  #pred2<-matrix(pred, ncol=length(landus), nrow=length(tempus), byrow=T)
  #image(land,temp,pred2)
  # head(pred2)
  # pras<-raster(pred2, xmn=min(landus), xmx=max(landus), ymn=min(tempus), ymx=max(tempus))
  # 
  #pred_pcnt<-((10^pred2) - 1)    #for lambda sum this is total population change, for lambda mean this is average annual rate of change
  #pcntras<-raster(pred_pcnt, xmn=min(landus), xmx=max(landus), ymn=min(tempus), ymx=max(tempus))
  
  # p3s <- predict(mav,rcmd,re.form=NA) 
  # 
  # p4s<-raster(matrix(p3s, nrow=280, ncol=720, byrow=T))
  # 
 # file_m<-paste("predict_", i,".tif" ,sep="")
  # file_pl<-paste("world_plot", i, ".tif", sep="")
 # writeRaster(pcntras, filename=file_m, overwrite=TRUE)
  # writeRaster(p4s, filename = file_pl, overwrite=TRUE)
  print(i)
}
```

```{r}
land<-seq(min(dt$Nat_loss),max(dt$Nat_loss),length.out=100)
temp<-seq(min(dt$mean_slope_scale),max(dt$mean_slope_scale),length.out=100)
body<-seq(min(dt$Bodymass),max(dt$Bodymass),length.out=100)

pr_dfx<-expand.grid(land, temp, dt$Binomial)

colnames(pr_dfx)<-c("change_rate_scale", "mean_slope_scale", "Binomial")
#prd<-predict(m1, pr_dfx)


p <- ggplot(sp_dups_df2, aes(x = sp_dups_df2$mean_slope_scale, y = sp_dups_df2$lambda_mean, colour = sp_dups_df2$Binomial)) +
  geom_point(size=3) +
  geom_line(aes(y = predict(m1b)),size=1) 
print(p)

```

```{r}
list<-list.files(path = getwd(), pattern = "predict.*\\.tif$")

br<-stack(list)

br_av<-mean(br)


#plot(br_av, xlab="Land Use Change Distance", ylab="Annual Mean Temperature Change", main="Total Population Change (%) - Birds")
#points(df2$LUC, df2$Estimate, col=df2$WWF_REALM2, pch=16)


#writeRaster(br_av, "Birds_and_Mammals_Prediction_Average_Raster_Lambda_mean_noclimbuff.tif", overwrite=TRUE)

```

```{r}
a<-seq(1:100)
b<-seq(1:100)
ab<-expand.grid(a,b)  
ab$c<-ab$Var1*ab$Var2
abm<-matrix(ab$c, ncol=length(a), nrow=length(b),byrow=F)
plot(raster(abm))

```

```{r}
library(ggplot2)

br_avp<-rasterToPoints(br_av)

br_av_df <- data.frame(br_avp)
colnames(br_av_df) <- c("Land_Use_Change", "Annual_Mean_Temperature_Change", "Population")

df2$LUC<-(df2$LUC/sqrt(2))*100
```

```{r}
xydata<-data.frame(df2$LUC, df2$Estimate, df2$WWF_REALM2)
colnames(xydata)<-c("Land_Use", "Mean_Temp", "Realm")

ggplot(data=br_av_df, aes(y=Annual_Mean_Temperature_Change, x=Land_Use_Change)) +
geom_raster(aes(fill=Population)) +
geom_point(data=xydata, aes(x=Land_Use, y=Mean_Temp,colour=Realm),size=2) +
theme_bw() +
scale_fill_continuous("Average Annual \nPopulation Change (%)", low="black", high="white")+
theme(axis.title.x = element_text(size=16),
axis.title.y = element_text(size=16, angle=90),
axis.text.x = element_text(size=14),
axis.text.y = element_text(size=14),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
legend.position = "right",
legend.key = element_blank()
)+
labs(x="Land Use Change (%)", y="Annual Mean Temperature" *-Change~degree*C)

hist(df2$Estimate, breaks=100, xlab="Annual Mean Temperature " *Change~degree*C, main="")

hist(df2$LUC_dist/sqrt(2), breaks=100, xlab="Percentage Land Use Change", main="")
```

```{r}
plist<-list.files(path = getwd(), pattern = "world_plot.*\\.tif$")

plr<-stack(plist)

plr_av<-mean(plr)

```

```{r}
plr_av2<-(10^plr_av) - 1

extent(plr_av2)<-c(-180, 180, -56, 84)


plr_avp<-rasterToPoints(plr_av2)

plr_av_df <- data.frame(plr_avp)
colnames(plr_av_df) <- c("Longitude", "Latitude", "Population")

# xydata<-data.frame(df2$Longitude, df2$Latitude, df2$WWF_REALM2)
# colnames(xydata)<-c("Land_Use", "Mean_Temp", "Realm")

ggplot(data=plr_av_df, aes(y=Latitude, x=Longitude)) +
geom_raster(aes(fill=Population)) +
theme_bw() +
scale_fill_continuous(low="light grey", high="darkred")+
theme(axis.title.x = element_text(size=16),
axis.title.y = element_text(size=16, angle=90),
axis.text.x = element_text(size=14),
axis.text.y = element_text(size=14),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
legend.position = "right",
legend.key = element_blank()
)+
labs(x="Longitude", y="Latitude", colourbar= "Average Annual Population Change (%)")


```


```{r}
AIC_df<-data.frame(cbind(AIC_m0,AIC_m1,AIC_m1a, AIC_m1b, AIC_m1c, AIC_mnull))

AIC_del<-AIC_df[,c(1:5)] - AIC_df$AIC_mnull

colMeans(AIC_del)

boxplot(AIC_del, main="Difference in AIC from Null Model")

```

```{r}
mean(marg_Rsq_m0)
mean(marg_Rsq_m1)
mean(marg_Rsq_m1a)
mean(marg_Rsq_m1b)
mean(marg_Rsq_m1c)

mean(cond_Rsq_m0)
mean(cond_Rsq_m1)
mean(cond_Rsq_m1a)
mean(cond_Rsq_m1b)
mean(cond_Rsq_m1c)
mean(cond_Rsq_mnull)

mean(m0_w)
mean(m1_w)
mean(m1a_w)
mean(m1b_w)
mean(m1c_w)
mean(mnull_w)

```


```{r}

Low<-(R+1)/40
High<-(R+1)-(R+1)/40 


mean_av<- c(mean(LUC_av),mean(MTC_av),mean(LUC_MTC_av))
lowCI_av<-c(sort(LUC_av)[Low], sort(MTC_av)[Low], sort(LUC_MTC_av)[Low])
highCI_av<-c(sort(LUC_av)[High], sort(MTC_av)[High], sort(LUC_MTC_av)[High])

Variable<-c("Natural Cover \nLoss", "Mean Temp. \nChange", "Interaction")

conf_av<-data.frame(rbind( lowCI_av, mean_av, highCI_av))
colnames(conf_av)<-Variable
conf_av

library(plotrix)

plotCI(1:3, mean_av, (highCI_av-mean_av), (mean_av-lowCI_av), ylab="Coefficient (95% C.I.)", xlab="" ,xaxt = "n", 
       main="Averaged Model Variable Coefficients - Non-Migratory Birds", lwd=1, ylim=c(min(lowCI_av*1.1), max(highCI_av*1.1)))
axis(1, at=1:3, labels=colnames(conf_av), las=2)
abline(h=0, col="red", lty =2)

```

```{r}


AIC_av<- c(mean(AIC_m1),mean(AIC_m1a),mean(AIC_m1b), mean(AIC_m1c), mean(AIC_mnull))
low_AIC<-c(sort(AIC_m1)[Low], sort(AIC_m1a)[Low], sort(AIC_m1b)[Low], sort(AIC_m1c)[Low], sort(AIC_mnull)[Low])
high_AIC<-c(sort(AIC_m1)[High], sort(AIC_m1a)[High], sort(AIC_m1b)[High], sort(AIC_m1c)[High], sort(AIC_mnull)[High])

Variable<-c("LUC*MTC", "LUC+MTC", "LUC", "MTC", "Null")

conf_av<-data.frame(rbind( AIC_av, low_AIC, high_AIC))
colnames(conf_av)<-Variable
conf_av

library(plotrix)

plotCI(1:5, AIC_av, (high_AIC-AIC_av), (AIC_av-low_AIC), ylab="AIC values (95% C.I.)", xlab="" ,xaxt = "n", 
       main="Distribution of AIC - Non-Migratory Birds", lwd=1, ylim=c(min(low_AIC*1.01), max(high_AIC*0.99)))
axis(1, at=1:5, labels=colnames(conf_av), las=2)
abline(h=mean(AIC_mnull), col="red", lty =2)
```

```{r}
###plotting difference between interaction and null 
plot(AIC_m1, ylab="AIC value", xlab="Model Run", ylim=c(-320, -200))
points(AIC_mnull, col="red")

plot(AIC_m1 - AIC_mnull, main="Difference in AIC between Interacting and Null Model - Birds", ylab="Delta AIC", xlab="Model Run", )
abline(h=0, col="red", lty =2)

```

```{r}
#install.packages('ggthemes', dependencies = TRUE)

library(ggplot2)
library(ggthemes)
library(palettetown)
library(reshape2)

#AIC_df<-data.frame(AIC_m1, AIC_m1a, AIC_m1b, AIC_m1c, AIC_mnull)
colnames(AIC_del)<-c("BM+LUC*MTC", "LUC*MTC", "LUC+MTC", "LUC", "MTC")
AIC_del2<-melt(AIC_del)
colnames(AIC_del2)<-c("Model", "AIC")

p<-ggplot(AIC_del2, aes(x=factor(Model), y=AIC, fill=factor(Model)))
p+geom_violin(trim=TRUE) +
xlab("Model")+
scale_fill_poke(pokemon = 'Vaporeon', spread = 5)


```

```{r}

mean_rsq<-c(mean(marg_Rsq_m1), mean(marg_Rsq_m1a), mean(marg_Rsq_m1b), mean(marg_Rsq_m1c))*100
low_rsq<-c(sort(marg_Rsq_m1)[Low], sort(marg_Rsq_m1a)[Low], sort(marg_Rsq_m1b)[Low], sort(marg_Rsq_m1c)[Low])*100
high_rsq<-c(sort(marg_Rsq_m1)[High], sort(marg_Rsq_m1a)[High], sort(marg_Rsq_m1b)[High], sort(marg_Rsq_m1c)[High])*100

Variable<-c("LUC*MTC", "LUC+MTC", "LUC", "MTC")

rsq_df<-data.frame(rbind(low_rsq, mean_rsq, high_rsq))
colnames(rsq_df)<-Variable


library(plotrix)

plotCI(1:4, mean_rsq, (high_rsq-mean_rsq), (mean_rsq-low_rsq), ylab="R squared value (%) (95% C.I.)", xlab="" ,xaxt = "n", 
       main="Distribution of R squared - Migratory Birds", lwd=1, ylim=c(min(low_rsq*1.01), max(high_rsq*0.99)))
axis(1, at=1:4, labels=colnames(rsq_df), las=2)



```

```{r}
w_av<- c(mean(m1_w),mean(m1a_w),mean(m1b_w), mean(m1c_w), mean(mnull_w))*100
low_w<-c(sort(m1_w)[Low], sort(m1a_w)[Low], sort(m1b_w)[Low], sort(m1c_w)[Low], sort(mnull_w)[Low])*100
high_w<-c(sort(m1_w)[High], sort(m1a_w)[High], sort(m1b_w)[High], sort(m1c_w)[High], sort(mnull_w)[High])*100

Variable<-c("LUC*MTC", "LUC+MTC", "LUC", "MTC", "Null")

conf_av<-data.frame(rbind(w_av, low_w, high_w))
colnames(conf_av)<-Variable
conf_av

library(plotrix)

plotCI(1:5, w_av, (high_w-w_av), (w_av-low_w), ylab="Model Weight Values (95% C.I.)", xlab="" ,xaxt = "n", 
       main="Distribution of Model Weight - Birds", lwd=1, ylim=c(min(low_w*1.01), max(high_w*1.01)))
axis(1, at=1:5, labels=colnames(conf_av), las=2)


```

```{r,eval=FALSE, echo=FALSE}
Low<-(R+1)/40
High<-(R+1)-(R+1)/40 


mean_avus<- c(mean(LUC_avus),mean(MTC_avus))
lowCI_avus<-c(sort(LUC_avus)[Low], sort(MTC_avus)[Low])
highCI_avus<-c(sort(LUC_avus)[High], sort(MTC_avus)[High])

Variable<-c("LUC", "MTC")

conf_avus<-data.frame(rbind(lowCI_avus, mean_avus, highCI_avus))
colnames(conf_avus)<-Variable
conf_avus

library(plotrix)

plotCI(1:2, mean_avus, (highCI_avus-mean_avus), (mean_avus-lowCI_avus), ylab="Coefficient (95% C.I.)", xlab="" ,xaxt = "n", 
       main="Variable Coefficients", lwd=1, ylim=c(min(lowCI_avus*1.1), max(highCI_avus*1.1)))
axis(1, at=1:2, labels=colnames(conf_avus), las=2)
abline(h=0, col="red", lty =2)

```

```{r,eval=FALSE, echo=FALSE}


m1<-lmer(lambda_mean ~ change_rate_scale+mean_slope_scale+change_rate_scale:mean_slope_scale+(1|Binomial),data=sp_df_scale, REML=F)
 
p3s <- predict(m1,rcmd,re.form=NA) 

p4s<-raster(matrix(p3s, nrow=280, ncol=720, byrow=T))

plot(p4s)
p5s<-(10^p4s) - 1
plot(p5s)
```

```{r, eval=FALSE, echo=FALSE}

for (i in 1:R) {
  dt2<-data.frame(dt[, ID[sample.int(.N, 1, TRUE)], by = loc_id])     #.N     signifies the number of rows when using data.table
  colnames(dt2)[2]<-"ID"
  sp_dups_df2<-sp_df_scale[sp_df_scale$ID %in% dt2$ID,]

  m1<-lmer(lambda_mean ~ change_rate_scale+mean_slope_scale+change_rate_scale:mean_slope_scale+(1|Binomial),data=sp_dups_df2, REML=F)
  
  m1a<-lmer(lambda_mean ~ change_rate_scale+mean_slope_scale+(1|Binomial),data=sp_dups_df2, REML=F)
  
  m1b<-lmer(lambda_mean ~ change_rate_scale+(1|Binomial),data=sp_dups_df2, REML=F)
  
  m1c<-lmer(lambda_mean ~ mean_slope_scale+(1|Binomial),data=sp_dups_df2, REML=F)
  
  mnull<-lmer(lambda_mean ~ 1+(1|Binomial),data=sp_dups_df2, REML=F)
  

```

